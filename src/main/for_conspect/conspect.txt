Bean scope

Scope (Область видимости) определяет:
    жизненный цикл бина
    возможное количество создаваемых бинов

Разновидности bean scope:
    singletone
    prototype
    request
    session
    global-session

Singletone - это дефолтный scope. Такой бин:
    создается сразу после прочтения Spring Container-ом конфиг файла
    является общим для всех, кто запросит его у Spring Container-а
    подходит для stateless объектов

Prototype - такой бин:
    создается только после обращения к Spring Container-у c помощью метода getBean
    для каждого такого обращения создается новый бин в Spring Container-е
    подходит для stateful объектов

Жизненный цикл бина (слайд 18)

Запуск приложения - начала работы Spring Container - Создание бина - внедряются зависимости (DI) - init method
- бин готов для использования - использование нами этого бина - конец работы Spring Container - destroy method
- остановка приложения

Чаще всего init-method используется для открытия или настройки каких-либо ресурсов, например баз данных, стримов и т.д.
destroy-method чаще всего используется для их закрытия

У данных методов access modifier может быть любой
У данных методов return type может быть любым. Но из-за того, что возвращаемое значение мы никак не можем использовать,
чаще всего return type - это void
Называться данные методы могут как угодно
В данных методах не должно быть параметров

Если у бина Scope prototype, то:
    init-method будет вызываться для каждого новосозданного бина
    для этого бина destroy-method вызываться не будет
    программисту необходимо самостоятельно писать код для закрытия/освобождения ресурсов, которые были использованы в бине



Конфигурация с помощью аннотаций

Аннотация - это специальные комментарии/метки/метаданные, которые нужны для передачи определенной информации.
Конфигурация с помощью аннотаций более короткий и быстрый способ, чем конфигурация с помощью XML файла
Процесс состоит из 2-х этапов:
    1. Сканирование классов и поиск аннотации @Component
    2. Создание (регистрация) бина в Spring Container-е

Если к аннотации @Component не прописать bean id, то бину будет назначен дефолтный id.
Дефолтный bean id получается из имена класса, заменяя его первую заглавную букву на прописную



@Autowired

Для внедрения зависимостей с помощью аннотаций используется аннотация @Autowired.
Типы autowiring или где мы можем использоваться данный DI:
    конструктор
    сеттер
    поле

Процесс внедрения зависимостей при использовании @Autowired такой:
    1. Сканирование пакета, поиск классов с аннотацией @Component
    2. При наличие аннотации @Autowired начинается поиск подходящего по типу бина
    3. Далее ситуация развивается по одному из сценариев:
        a. Если находится 1 подходящий бин, происходит внедрение зависимости
        b. Если подходящих по типу бинов нет, то выбрасывается исключение
        с. Если подходящих по типу бинов больше одного, тоже выбрасывается исключение



@Qualifier

Если при использовании @Autowired подходящих по типу бинов больше одного, то выбрасывается исключение. Предотвратить
выброс данного исключения можно конкретно указав, какой бин должен быть внедрен. Для этого и используют аннотацию @Qualifier


@Value

Для внедрения срок и других значений можно использовать аннотацию @Value. В этом случае в сеттерах нет необходимости, как
это было при конфигурации с помощью XML файла.


Конфигурация Spring Container с помощью Java кода.

Способ 1

Аннотация @Configuration означает, что данный класс является конфигурацией.
С помощью аннотации @ComponentScan мы показываем, какой пакет нужно сканировать на наличие бинов и разных аннотаций.

При использовании конфигурации с помощью Java кода, Spring Container будет представлен классом AnnotationConfigApplicationContext

Способ 2

Данный способ не использует сканирование пакета и поиск бинов. Здесь бины описываются в конфиг классе.
Данный способ не использует аннотацию @Autowired. Здесь зависимости прописываются вручную.
Название метода - это bean id/
Аннотация @Bean перехватывает все обращения к бину и регулирует его создание.


@PropertySource

Аннотация @PropertySource указывает на property файл откуда мы можем использовать значение для полей



Aspect Oriented Programming (Аспектно Ориентированное Программирование)

Проблемы, с которыми мы сталкиваемся:
    Переплетение бизнес-логики со служебным функционалом (Code tangling). Метод становится громоздким, и его основной функционал
    сразу не заметно.
    Разбросанность служебного функционала по всему проекту (Code scattering). При необходимости что-то изменить в служебном функционале,
    мы должны будем делать изменения во всех классах

AOP - парадигма программирования, основанная на идеи разделения основного и служебного функционала. Служебный функционал
записывается в Aspect-классы. В основе Aspect заключена сквозная логика (cross-cutting logic)

К сквозному функционалу относят:
    Логирование
    Проверка прав (security check)
    Обработка транзакций
    Обработка исключений
    Кеширование
    И т.д.

Слайд 41, 42б 43

Плюсы AOP:
    Сквозной функционал сосредоточен в 1-м или нескольких обособленных классах. Это позволяет легче его изменять.
    Становится легче добавлять новые сквозные работы для нашего основного кода или имеющиеся сквозные работы для новых классов.
    Это достигается благодаря конфигурации аспектов.
    Бизнес-код приложения избавляется от сквозного кода, становится меньше и чище. Работать с ним становится легче.

Минус AOP:
    Дополнительное время на работу аспектов.

Слайд 46

Aspect - это класс, отвечающий за сквозную функциональность.
@EnableAspectJAutoProxy позволяет нам за кулисами использовать Spring AOP Proxy
@Aspect говорит о том, что это не простой класс, а Aspect. Поэтому к данному классу Spring будет относиться по другому

Advice - метод, который находится в Aspect и содержит сквозную логику. Advice определяет, что и когда должно происходить.
В идеале Advice должен быть небольшим и быстро работающим.

Типы Advice
    Before - выполняются до метода с основной логикой
    After returning - выполняется только после нормального окончания метода с основной логикой
    After throwing - выполняется после окончания метода с основной логикой только, если было выброшено исключение
    After/After finally - выполняется после окончания метода с основной логикой
    Around - выполняется до и после метода с основной логикой

Pointcut - выражение, описывающие где должен быть применен Advice.