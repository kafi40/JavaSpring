Bean scope

Scope (Область видимости) определяет:
    жизненный цикл бина
    возможное количество создаваемых бинов

Разновидности bean scope:
    singletone
    prototype
    request
    session
    global-session

Singletone - это дефолтный scope. Такой бин:
    создается сразу после прочтения Spring Container-ом конфиг файла
    является общим для всех, кто запросит его у Spring Container-а
    подходит для stateless объектов

Prototype - такой бин:
    создается только после обращения к Spring Container-у c помощью метода getBean
    для каждого такого обращения создается новый бин в Spring Container-е
    подходит для stateful объектов

Жизненный цикл бина (слайд 18)

Запуск приложения - начала работы Spring Container - Создание бина - внедряются зависимости (DI) - init method
- бин готов для использования - использование нами этого бина - конец работы Spring Container - destroy method
- остановка приложения

Чаще всего init-method используется для открытия или настройки каких-либо ресурсов, например баз данных, стримов и т.д.
destroy-method чаще всего используется для их закрытия

У данных методов access modifier может быть любой
У данных методов return type может быть любым. Но из-за того, что возвращаемое значение мы никак не можем использовать,
чаще всего return type - это void
Называться данные методы могут как угодно
В данных методах не должно быть параметров

Если у бина Scope prototype, то:
    init-method будет вызываться для каждого новосозданного бина
    для этого бина destroy-method вызываться не будет
    программисту необходимо самостоятельно писать код для закрытия/освобождения ресурсов, которые были использованы в бине



Конфигурация с помощью аннотаций

Аннотация - это специальные комментарии/метки/метаданные, которые нужны для передачи определенной информации.
Конфигурация с помощью аннотаций более короткий и быстрый способ, чем конфигурация с помощью XML файла
Процесс состоит из 2-х этапов:
    1. Сканирование классов и поиск аннотации @Component
    2. Создание (регистрация) бина в Spring Container-е

Если к аннотации @Component не прописать bean id, то бину будет назначен дефолтный id.
Дефолтный bean id получается из имена класса, заменяя его первую заглавную букву на прописную



@Autowired

Для внедрения зависимостей с помощью аннотаций используется аннотация @Autowired.
Типы autowiring или где мы можем использоваться данный DI:
    конструктор
    сеттер
    поле

Процесс внедрения зависимостей при использовании @Autowired такой:
    1. Сканирование пакета, поиск классов с аннотацией @Component
    2. При наличие аннотации @Autowired начинается поиск подходящего по типу бина
    3. Далее ситуация развивается по одному из сценариев:
        a. Если находится 1 подходящий бин, происходит внедрение зависимости
        b. Если подходящих по типу бинов нет, то выбрасывается исключение
        с. Если подходящих по типу бинов больше одного, тоже выбрасывается исключение



@Qualifier

Если при использовании @Autowired подходящих по типу бинов больше одного, то выбрасывается исключение. Предотвратить
выброс данного исключения можно конкретно указав, какой бин должен быть внедрен. Для этого и используют аннотацию @Qualifier


@Value

Для внедрения срок и других значений можно использовать аннотацию @Value. В этом случае в сеттерах нет необходимости, как
это было при конфигурации с помощью XML файла.


Конфигурация Spring Container с помощью Java кода.

Способ 1

Аннотация @Configuration означает, что данный класс является конфигурацией.
С помощью аннотации @ComponentScan мы показываем, какой пакет нужно сканировать на наличие бинов и разных аннотаций.

При использовании конфигурации с помощью Java кода, Spring Container будет представлен классом AnnotationConfigApplicationContext

Способ 2

Данный способ не использует сканирование пакета и поиск бинов. Здесь бины описываются в конфиг классе.
Данный способ не использует аннотацию @Autowired. Здесь зависимости прописываются вручную.
Название метода - это bean id/
Аннотация @Bean перехватывает все обращения к бину и регулирует его создание.


@PropertySource

Аннотация @PropertySource указывает на property файл откуда мы можем использовать значение для полей



Aspect Oriented Programming (Аспектно Ориентированное Программирование)

Проблемы, с которыми мы сталкиваемся:
    Переплетение бизнес-логики со служебным функционалом (Code tangling). Метод становится громоздким, и его основной функционал
    сразу не заметно.
    Разбросанность служебного функционала по всему проекту (Code scattering). При необходимости что-то изменить в служебном функционале,
    мы должны будем делать изменения во всех классах

AOP - парадигма программирования, основанная на идеи разделения основного и служебного функционала. Служебный функционал
записывается в Aspect-классы. В основе Aspect заключена сквозная логика (cross-cutting logic)

К сквозному функционалу относят:
    Логирование
    Проверка прав (security check)
    Обработка транзакций
    Обработка исключений
    Кеширование
    И т.д.

Слайд 41, 42б 43

Плюсы AOP:
    Сквозной функционал сосредоточен в 1-м или нескольких обособленных классах. Это позволяет легче его изменять.
    Становится легче добавлять новые сквозные работы для нашего основного кода или имеющиеся сквозные работы для новых классов.
    Это достигается благодаря конфигурации аспектов.
    Бизнес-код приложения избавляется от сквозного кода, становится меньше и чище. Работать с ним становится легче.

Минус AOP:
    Дополнительное время на работу аспектов.

Слайд 46

Aspect - это класс, отвечающий за сквозную функциональность.
@EnableAspectJAutoProxy позволяет нам за кулисами использовать Spring AOP Proxy
@Aspect говорит о том, что это не простой класс, а Aspect. Поэтому к данному классу Spring будет относиться по другому

Advice - метод, который находится в Aspect и содержит сквозную логику. Advice определяет, что и когда должно происходить.
В идеале Advice должен быть небольшим и быстро работающим.

Типы Advice
    Before - выполняются до метода с основной логикой
    After returning - выполняется только после нормального окончания метода с основной логикой
    After throwing - выполняется после окончания метода с основной логикой только, если было выброшено исключение
    After/After finally - выполняется после окончания метода с основной логикой вне зависимости от того, завершается ли метод нормально
    или выбрасывается исключение.
    Around - выполняется до и после метода с основной логикой

Pointcut - выражение, описывающие где должен быть применен Advice.

Spring AOP использует AspectJ Pointcut expression language. T.e. определенные правила в написании выражений для создания Pointcut.

Для того чтобы не пользоваться copy-paste когда для нескольких Advice подходит один и тот же Pointcut, есть возможность объявить данный
Pointcut и затем использовать его несколько раз.
Плюсы объявления Pointcut:
    Возможность использование созданного Pointcut для множества Advice
    Возможность быстрого изменения Pointcut expression для множества Advice
    Возможность комбинирования Pointcut

Комбинирование Pointcut - это их объединение с помощью логических операторов &&, ||, !

Порядок выполнения Aspect
    Если при вызове 1-го метода с бизнес-логикой срабатывают несколько Advice, то нет никакой гарантии в порядке выполнения этих
    Advice.
    Для соблюдения порядка такие Advice нужно распределять по отдельным упорядоченным Aspect
    @Order упорядочивает Aspect. Чем меньше число, тем выше приоритет.



Join Point

Join Point - это точка/момент в выполняемой программе когда следует применять Advice. Т.е. это точка переплетения метода с бизнес-логикой
и метода со служебным функционалом.
Прописав Join Point в параметре метода Advice, мы получаем доступ к информации о сигнатуре и параметрах метода с бизнес-логикой.



@AfterReturning

@AfterReturning Advice выполняется только после нормального окончания метода с основной логикой, но до присвоения результата этого метода какой-либо переменной.
Поэтому с помощью @AfterReturning Advice возможно изменять возвращаемый результат метода.


@AfterThrowing

@AfterThrowing Advice не влияет на протекание программы при выбрасывании исключения. С помощью @AfterThrowing Advice можно получить доступ к исключению,
которое выбросилось из метода с основной логикой.

@After

С помощью @After Advice невозможно:
    1) Получить доступ к исключению, которое выбросилось из метода с основной логикой.
    2) Получить доступ к возвращаемому методом результату

@Around

С помощью @Around Advice возможно:
    1) Произвести какие-либо действия до работы target метода
    2) Произвести какие-либо действия после работы target метода
    3) Получать результат работы target метода/изменить его
    4) Предпринять какие-либо действия, если из target метода выбрасывается исключение

Используя @Around Advice возможно предпринять следующие действия, если из target метода выбрасывается исключение:
    Ничего не делать
    Обрабатывать исключение
    Пробрасывать исключение дальше



Hibernate

Hibernate - это framework, который используется для сохранения, получения, изменения и удаления Java объектов из Базы Данных.
ORM (Object-to-Relational Mapping) - это преобразование объекта в строку в таблице и обратное преобразование (слайд 70).
Слайд 71
Слайд 73

Плюсы Hibernate:
    Предоставляет технологию ORM
    Регулирует SQL запросы
    Уменьшает количество кода для написания

CRUD
CREATE - команда INSERT
READ - команда SELECT
UPDATE - команда UPDATE
DELETE - команда DELETE

Конфигурировать связь между классом и таблицей можно 2-мя способами:
    С помощью XML файла
    С помощью Java аннотаций

Entity класс - это Java класс, который отображает информацию определенной таблицы в Базе Данных.
Entity класс - это POJO класс, в котором мы используем определенные Hibernate аннотации для связи класса таблицей из базы.
POJO (Plain Old Java Object) - класс, удовлетворяющий ряду условий:
    private поля
    getters and setters
    no args constructor
Аннотация @Entity говорит о том, что данный класс будет иметь отображения в базе данных.
Аннотация @Table говорит о том, к какой именно таблице мы привязываем класс.
Аннотация @Column говорит о том, к какому именно столбцу из таблицы мы привязываем поле класса
Аннотация @Id говорит о том, что в таблице, столбец связанный с данным полем является Primary Key
JPA (Java Persistence API) - это стандартная спецификация, которая описывает систему для управления сохранением Java объектов
в таблицы базы данных.
Hibernate - самая популярная реализация спецификации JPA. Таким образом JPA описывает правила, а Hibernate реализует их.

SessionFactory

SessionFactory - фабрика по производству сессий.
SessionFactory читает файл hibernate.cfg.xml, после чего SessionFactory знает, как должны создаваться сессии.
В Java приложении достаточно создать объект SessionFactory 1 раз и затем можно его переиспользовать.
Session - это обертка вокруг подключения к базе с помощью JDBC.
Session мы получаем с помощью SessionFactory.
Session - это основа для работы с базой данных. Именно с помощью Session мы будем добавлять, получать и делать другие операции
с Java объектами в базе данных. Жизненный цикл Session обычно не велик. Мы получаем Session, делаем с помощью нее определенные операции и она
становится не нужной.

Primary Key

Столбец с Primary Key содержит уникальные значения и не может быть null.
Аннотация @GeneratedValue описывает стратегию по генерации значений для столбца с Primary Key.
GenerationType.IDENTITY полагается на автоматическое увеличение столбца по правилам, прописанным в БД.
GenerationType.SEQUENCE полагается на работу Sequence созданного в БД.
GenerationType.TABLE полагается на значение столбца таблицы БД. Цель такой таблицы - поддержка уникальности значений.
GenerationType.AUTO дефолтный тип. Выбор стратегии будет зависеть от типа базы, с которой мы работаем.

Для получения объектов из базы используется HQL (Hibernate Query Language). HQL очень схож с SQL.

Типы отношений таблиц

One-to-One (Один-к-Одному) слайд 89
One-to-Many (Отношение Один-ко-Многим) слайд 90
Many-to-One (Отношение Многие-к-Одному) слайд 90
Many-to-Many (Отношение Многие-ко-Многим) слайд 91

Foreign Key

Foreign Key - внешний ключ.
Foreign Key используется для создания связи между двумя таблицами.
Обычно Foreign Key это столбец, который ссылается на Primary Key столбец другой таблицы.
Foreign Key столбец не может содержать информацию, которой нет в столбце, на который он ссылается

Uni и Bi-directional associations

Uni-directional - это отношения, когда одна сторона о них не знает.
Bi-directional - это отношения, когда обе стороны знают друг о друге.
Аннотация @OneToOne указывает на тип отношений между объектами.
Аннотация @JoinColumn указывает на столбец, который осуществляет связь с другим объектом.
Cascade операций - это выполнение операции не только для Entity, на котором операция вызывается, но и на связанных с ним Entity.
В Bi-directional отношениях с помощью аннотации @OneToOne и mappedBy мы показываем Hibernate, где нужно искать связь между классами.
При использовании связи One-to-Many в аннотации @JoinColumn name будет ссылаться на Foreign Key не из source, а из target таблицы.

